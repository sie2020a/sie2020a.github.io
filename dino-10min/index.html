<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Water Swordsman Run</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;padding:0;background:#0b0f14;color:#e6eef7;font-family:system-ui,-apple-system,sans-serif}
    header{padding:12px 16px;background:#10161d;border-bottom:1px solid #1f2a36;display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .hint{padding:8px 16px;font-size:14px;color:#a7b0ba}
    a{color:#7dd3fc}
    canvas{display:block;margin:0 auto;background:#0f1520;width:min(96vw, 900px);height:auto;touch-action:none;-webkit-user-select:none;user-select:none}
    #btnAudio{font:inherit;padding:6px 10px;border:1px solid #1f2a36;border-radius:8px;background:#162133;color:#e6eef7;cursor:pointer}
    #btnAudio.on{background:#1b2b44}
  </style>
</head>
<body>
  <header>
    <div><strong>Water Swordsman Run</strong> â€” ã‚¿ãƒƒãƒ—/Space: ã‚¸ãƒ£ãƒ³ãƒ— ï¼ Enter: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</div>
    <button id="btnAudio">ğŸ”Š ON/OFF (M)</button>
  </header>
  <div class="hint">â€» BGM/SEã‚’ä½¿ã†å ´åˆã¯ <code>sounds/</code> ã‚’ç”¨æ„ã—ã¦ audio ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å¤–ã›ã°OKã€‚</div>

  <canvas id="canvas" width="900" height="506"></canvas>

  <!-- ä»»æ„ã®åŠ¹æœéŸ³ï¼ˆç½®ã„ãŸã‚‰ã‚³ãƒ¡ãƒ³ãƒˆè§£é™¤ï¼‰
  <audio id="seJump" src="sounds/jump.mp3" preload="auto"></audio>
  <audio id="seHit"  src="sounds/hit.mp3"  preload="auto"></audio>
  <audio id="bgm"    src="sounds/bgm.mp3"  preload="auto" loop></audio>
  -->

  <script>
  // ========= åŸºæœ¬ =========
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const btnAudio = document.getElementById('btnAudio');

  const game = {
    counter: 0, score: 0, isGameOver: true, timer: null,
    enemys: [], enemyCooldown: 0, speedBase: 7,
    effects: [], parallaxT: 0
  };

  function init(){
    game.counter=0; game.score=0; game.isGameOver=false;
    game.enemys=[]; game.enemyCooldown=20; game.speedBase=7;
    game.effects=[]; game.parallaxT=0;
    createHero();
    clearInterval(game.timer);
    game.timer=setInterval(ticker, 30);
    drawBanner("Ready? ã‚¿ãƒƒãƒ—/Spaceã§é–‹å§‹");
  }

  function activate(){
    // åˆå›å…¥åŠ›ã§BGMè§£ç¦
    if (!bgm.isStarted()) bgm.start();

    // ã‚¹ãƒãƒ›ã§åˆ¥ã‚¢ãƒ—ãƒªâ†’æˆ»ã‚‹æ™‚ã®å¾©å¸°ï¼ˆiOSã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ãªã®ã§activateã§OKï¼‰
    bgm.resumeHard();

    if (game.isGameOver){ init(); setTimeout(()=>jump(),50); }
    else { jump(); }
  }

  // ========= èƒŒæ™¯ï¼ˆå¤œç©ºï¼‹å±±å½±ï¼‹æ˜Ÿï¼‰ =========
  function drawBackground(){
    const g=ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,"#0b1220"); g.addColorStop(0.6,"#0f1b2b"); g.addColorStop(1,"#121926");
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

    // æ˜Ÿ
    ctx.fillStyle="#dbeafe";
    for(let i=0;i<40;i++){
      const x=((i*97 + game.counter*0.6)%canvas.width), y=(i*53% (canvas.height*0.5));
      ctx.globalAlpha=0.4+0.6*Math.sin((game.counter+i)*0.02);
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha=1;

    // å±±ï¼ˆãƒ‘ãƒ©ãƒ©ãƒƒã‚¯ã‚¹ï¼‰
    game.parallaxT += 0.8;
    const drawHill=(y,amp,color)=>{
      ctx.fillStyle=color;
      ctx.beginPath(); ctx.moveTo(0,canvas.height);
      for(let x=0;x<=canvas.width;x+=8){
        const h = Math.sin((x+game.parallaxT)*0.005)*amp
                + Math.sin((x+game.parallaxT*0.7)*0.011)*amp*0.6;
        ctx.lineTo(x, y+h);
      }
      ctx.lineTo(canvas.width,canvas.height);
      ctx.closePath(); ctx.fill();
    };
    drawHill(canvas.height-180, 16, "#0c1624");
    drawHill(canvas.height-140, 22, "#0d1a2b");
  }

  // ========= åœ°é¢ =========
  let groundOffset=0;
  function drawGround(){
    groundOffset=(groundOffset+6)%40;
    ctx.fillStyle="#1a2431"; ctx.fillRect(0,canvas.height-70,canvas.width,70);
    ctx.strokeStyle="#243243"; ctx.lineWidth=2; ctx.beginPath();
    for(let x=-groundOffset; x<canvas.width; x+=40){
      ctx.moveTo(x,canvas.height-40); ctx.lineTo(x+20,canvas.height-40);
    }
    ctx.stroke();
  }

  // ========= ä¸»äººå…¬ï¼ˆå¸‚æ¾æ¨¡æ§˜ã®â€œæ°´ã®å‰£å£«â€ï¼‰ =========
  function createHero(){ game.hero={ x:120, y:canvas.height-28, moveY:0, w:54, h:54 }; }

  function moveHero(){
    const d=game.hero; d.y+=d.moveY;
    const floorY=canvas.height - d.h/2 - 16;
    if(d.y>=floorY){ d.y=floorY; d.moveY=0; } else { d.moveY+=3; }
  }

  function drawHero(){
    const d=game.hero, bx=d.x-d.w/2, by=d.y-d.h/2;

    // èƒ´ï¼ˆãƒ™ãƒ¼ã‚¹ï¼‰
    ctx.fillStyle="#0b0f14";
    roundRect(bx, by+8, d.w, d.h-8, 8, true);

    // å¸‚æ¾æ¨¡æ§˜ï¼ˆç·‘Ã—é»’ï¼‰
    const cell=10, cols=Math.ceil(d.w/cell), rows=Math.ceil((d.h-8)/cell);
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        ctx.fillStyle=((r+c)%2===0) ? "#1db37f" : "#0f2030";
        ctx.fillRect(bx+c*cell, by+8+r*cell, Math.min(cell,d.w-c*cell), Math.min(cell,d.h-8-r*cell));
      }
    }
    // å¤–æ 
    ctx.strokeStyle="rgba(0,0,0,.25)"; ctx.lineWidth=2;
    roundRect(bx, by+8, d.w, d.h-8, 8, false);

    // å¸¯
    ctx.fillStyle="#36bfe6"; ctx.fillRect(bx+6, by+d.h-20, d.w-12, 6);

    // é ­
    ctx.fillStyle="#f1d4b7";
    roundRect(bx+8, by-10, d.w-16, 20, 10, true);
    // ç›®
    ctx.fillStyle="#0b0f14"; ctx.fillRect(bx+d.w-26, by-2, 6, 6);

    // ãƒãƒ•ãƒ©ãƒ¼ï¼ˆæ°´è‰²ï¼‰
    ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(bx+d.w-10, by+6);
    ctx.quadraticCurveTo(bx+d.w+10, by+2, bx+d.w+18, by+10); ctx.stroke();
  }

  function roundRect(x,y,w,h,r,fill=true){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    fill?ctx.fill():ctx.stroke();
  }

  // ========= æ•µ =========
  function spawnEnemy(){
    const fly = Math.random() < 0.35;   // ç‚ç‰
    if (fly){
      const y=Math.random()*120 + 180;
      game.enemys.push({ type:"flame", x:canvas.width+40, y, w:36, h:28, vx:-(9+Math.random()*4), t:0 });
    }else{
      const w=38+Math.floor(Math.random()*20), h=56+Math.floor(Math.random()*26);
      game.enemys.push({ type:"oni", x:canvas.width+w/2, y:canvas.height-h/2-16, w, h, vx:-(7+Math.random()*3), t:0, animSeed:Math.random()*100 });
    }
  }

  function moveEnemys(gs){
    for(const e of game.enemys){
      e.x += e.vx * (gs/7);
      e.t++;
      if(e.type==="oni"){
        e.y += Math.sin((e.t+e.animSeed)*0.22) * 0.6;         // å°ã•ãå¼¾ã‚€
        const dx = e.x - game.hero.x;                         // è¿‘ã¥ã„ãŸã‚‰åŠ é€Ÿ
        if (dx < 280) e.vx = Math.max(e.vx - 0.12, -14);
      }
    }
    game.enemys = game.enemys.filter(e=>e.x>-e.w);
  }

  function drawEnemys(){
    for(const e of game.enemys){
      if(e.type==="oni"){ drawOniRun(e); }
      else{
        const s = 1 + Math.sin(e.t*0.25)*0.06;
        ctx.save(); ctx.translate(e.x, e.y); ctx.scale(s,s);
        const grd=ctx.createRadialGradient(0,0,4,0,0,20);
        grd.addColorStop(0, "rgba(255,230,120,0.95)");
        grd.addColorStop(0.5,"rgba(254,153,74,0.9)");
        grd.addColorStop(1, "rgba(220,38,38,0.7)");
        ctx.fillStyle=grd; flamePath(0,0,24); ctx.fill(); ctx.restore();
      }
    }
  }

  // å·¦ï¼ˆâ†ï¼‰ã¸èµ°ã‚‹é¬¼
  function drawOniRun(e){
    const phase = (e.t + (e.animSeed||0)) * 0.18;
    const lean  = -0.28 + Math.sin(phase*0.7)*0.06;
    const stride = Math.sin(phase);
    const lift   = Math.abs(Math.cos(phase))*4;

    ctx.save(); ctx.translate(e.x, e.y + lift); ctx.rotate(lean);
    const w=e.w, h=e.h;

    // å½±
    ctx.save(); ctx.rotate(-lean);
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.beginPath(); ctx.ellipse(0, h/2+8, w*0.42, 6, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // èƒ´ä½“
    ctx.fillStyle="#6d4bbd"; roundRect(-w*0.45, -h*0.35, w*0.9, h*0.7, 10, true);
    // è…°
    ctx.fillStyle="#4f3796"; ctx.fillRect(-w*0.36, h*0.05, w*0.72, 6);
    // é ­
    ctx.fillStyle="#7b5add"; roundRect(-w*0.10, -h*0.62, w*0.58, h*0.46, 8, true);
    // è§’
    ctx.fillStyle="#eab308";
    triangle(-w*0.06,-h*0.62, -0,-h*0.50, -w*0.14,-h*0.50);
    triangle(+w*0.16,-h*0.65, +w*0.22,-h*0.53, +w*0.06,-h*0.53);
    // ç›®ï¼ˆå‰ï¼å·¦ï¼‰
    ctx.fillStyle="#0b0f14"; ctx.fillRect(-w*0.06, -h*0.44, 7, 7);
    // å£ï¼‹ç‰™
    ctx.fillStyle="#0b0f14"; ctx.fillRect(-w*0.08, -h*0.38, 9, 20);
    ctx.fillStyle="#fef3c7"; ctx.fillRect(-w*0.075, -h*0.36, 3, 6); ctx.fillRect(-w*0.075, -h*0.26, 3, 6);

    // è…•
    ctx.fillStyle="#6d4bbd";
    const faX = -w*0.46 + stride*4, faY = -2;  // å‰è…•
    roundRect(faX, faY, 14, 24, 4, true);
    const baX =  w*0.32 + stride*4, baY = 6;   // å¾Œè…•
    roundRect(baX, baY, 12, 22, 4, true);
    // çˆªï¼ˆå‰è…•ï¼‰
    ctx.strokeStyle="rgba(15,23,42,0.9)"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(faX-2, faY+22); ctx.lineTo(faX-8, faY+28);
    ctx.moveTo(faX+2, faY+22); ctx.lineTo(faX-4, faY+30);
    ctx.stroke();

    // è„š
    ctx.fillStyle="#5e43ac";
    const legSpan = w*0.30;
    roundRect(-legSpan - stride*6,  h*0.18, 18, 24, 4, true); // å‰è„š
    roundRect(+legSpan - stride*6,  h*0.14, 16, 22, 4, true); // å¾Œè„š
    ctx.restore();
  }

  function triangle(ax,ay,bx,by,cx,cy){ ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.lineTo(cx,cy); ctx.closePath(); ctx.fill(); }
  function flamePath(cx,cy,r){
    ctx.beginPath();
    ctx.moveTo(cx,cy-r*0.6);
    ctx.bezierCurveTo(cx+r*0.7, cy-r*0.9, cx+r*0.9, cy-r*0.1, cx, cy+r);
    ctx.bezierCurveTo(cx-r*0.9, cy-r*0.1, cx-r*0.7, cy-r*0.9, cx, cy-r*0.6);
    ctx.closePath();
  }

  // ========= æ°´ã®å‘¼å¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ =========
  function createWaterEffect(x,y){
    const forms=["crescent","spiral","splash"];
    const type=forms[Math.floor(Math.random()*forms.length)];
    const life=28+Math.floor(Math.random()*10);
    game.effects.push({ type,x,y,t:0,life, rot:(Math.random()*0.6-0.3), vx:3+Math.random()*2, scale:0.9+Math.random()*0.5 });
  }
  function updateEffects(){
    for(const e of game.effects){ e.t++; e.x+=e.vx; e.y+=Math.sin(e.t*0.2); }
    game.effects=game.effects.filter(e=>e.t<e.life);
  }
  function drawEffects(){
    for(const e of game.effects){
      const p=e.t/e.life, alpha=1-p, w=6*e.scale*(1-p*0.5);
      const col1=`rgba(56,189,248,${0.8*alpha})`, col2=`rgba(14,165,233,${0.95*alpha})`;
      ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(e.rot);
      const stroke=(lw)=>{ ctx.lineWidth=lw; ctx.strokeStyle=col2; };

      if(e.type==="crescent"){
        const r=64*e.scale; stroke(w);
        ctx.beginPath(); ctx.arc(0,0,r,-0.8,0.8); ctx.stroke();
        ctx.lineWidth=w*0.5; ctx.strokeStyle=col1;
        ctx.beginPath(); ctx.arc(0,0,r*0.82,-0.7,0.7); ctx.stroke();

      }else if(e.type==="spiral"){
        stroke(w);
        ctx.beginPath();
        for(let a=0;a<=Math.PI*1.7;a+=0.12){
          const rr=(12+a*26)*e.scale, px=Math.cos(a)*rr, py=Math.sin(a)*rr*0.7;
          if(a===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        } ctx.stroke();

      }else{
        for(let i=0;i<6;i++){
          const ang=(i/6)*Math.PI*1.25 - Math.PI*0.6, len=(32+i*12)*e.scale*(1+p*0.5);
          stroke(w*0.7);
          ctx.beginPath(); ctx.moveTo(0,0);
          ctx.quadraticCurveTo(Math.cos(ang)*len*0.6, Math.sin(ang)*len*0.4, Math.cos(ang)*len, Math.sin(ang)*len*0.7);
          ctx.stroke();
        }
        ctx.fillStyle=col1;
        for(let i=0;i<4;i++){
          const ang=(i/4)*Math.PI*1.2 - Math.PI*0.6 + Math.sin(e.t*0.2)*0.1;
          const r=4*(1-p)*e.scale;
          ctx.beginPath(); ctx.arc(Math.cos(ang)*50*e.scale, Math.sin(ang)*24*e.scale, r, 0, Math.PI*2); ctx.fill();
        }
      }
      ctx.restore();
    }
  }

  // ========= å½“ãŸã‚Šåˆ¤å®š =========
  function hitCheck(){
    const d=game.hero;
    for(const e of game.enemys){
      const hitX=Math.abs(d.x-e.x)<((d.w*0.75)/2 + (e.w*0.9)/2);
      const hitY=Math.abs(d.y-e.y)<((d.h*0.6)/2 + (e.h?e.h:28)*0.9/2);
      if(hitX && hitY) return true;
    } return false;
  }

  // ========= ãƒ«ãƒ¼ãƒ—/UI =========
  function drawScore(){ ctx.fillStyle="#e5edf5"; ctx.font="24px system-ui,sans-serif"; ctx.fillText(`score: ${game.score}`,12,34); }
  function drawBanner(text){
    ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="#fff"; ctx.font="bold 48px system-ui,sans-serif"; ctx.fillText(text,140,220);
  }
  function gameOver(){
    game.isGameOver=true; clearInterval(game.timer);
    ctx.fillStyle="#ef4444"; ctx.font="bold 64px system-ui,sans-serif"; ctx.fillText("Game Over!",230,220);
    ctx.fillStyle="#ddd"; ctx.font="24px system-ui,sans-serif"; ctx.fillText("Enterã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ / ã‚¿ãƒƒãƒ— or Spaceã§ã‚¸ãƒ£ãƒ³ãƒ—",180,264);
  }

  function ticker(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground(); drawGround();

    if(game.enemyCooldown<=0 && Math.random()<0.15){
      spawnEnemy(); game.enemyCooldown=Math.max(10,30-Math.floor(game.score/150));
    }else game.enemyCooldown--;

    const spdScale=1+Math.min(1.5, game.score/2200), groundSpeed=game.speedBase*spdScale;

    moveHero(); drawHero();
    updateEffects(); drawEffects();
    moveEnemys(groundSpeed); drawEnemys();

    if(hitCheck()){ gameOver(); return; }

    game.score += 1; drawScore();
    game.counter = (game.counter+1) % 1000000;
  }

  // ========= å…¥åŠ› =========
  function jump(){
    if(!game.isGameOver && game.hero.moveY===0){
      game.hero.moveY=-42;
      const d=game.hero;
      createWaterEffect(d.x + d.w*0.35, d.y - d.h*0.25);
      // playSE('seJump');
    }
  }

  document.addEventListener('keydown',(e)=>{
    if(e.code==="Space") activate();
    if(e.code==="Enter" && game.isGameOver) init();
    if(e.code==="KeyM"){ bgm.toggle(); btnAudio.classList.toggle('on', bgm.isPlaying()); }
  });
  canvas.addEventListener('pointerdown',(e)=>{ e.preventDefault(); activate(); });
  canvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); activate(); }, {passive:false});
  btnAudio.addEventListener('click', ()=>{ if(!bgm.isStarted()) bgm.start(); else bgm.toggle(); btnAudio.classList.toggle('on', bgm.isPlaying()); });

  // ===== ã‚¹ãƒãƒ›ã§è£ã«å›ã£ãŸã‚‰BGMåœæ­¢ï¼ˆä¸å…·åˆå¯¾ç­–ï¼‰ =====
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) bgm.pauseHard();
  });
  window.addEventListener("pagehide", () => bgm.pauseHard());
  window.addEventListener("blur", () => bgm.pauseHard());

  // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  ctx.fillStyle="#e5edf5"; ctx.font="bold 36px system-ui,sans-serif"; ctx.fillText("Water Swordsman Run",240,180);
  ctx.font="24px system-ui,sans-serif"; ctx.fillText("ã‚¿ãƒƒãƒ—/Spaceã§é–‹å§‹ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ï¼‰ / Enterã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ",170,222);
  </script>

  <script>
  // ===== BGM (Web Audio; çŒ—çª©åº§ã®åœ§Ã—å–„é€¸ã®ã‚­ãƒ¬ ã¿ãŸã„ãªâ€œé›°å›²æ°—â€å¯„ã›) =====
  const bgm = (() => {
    let ac, master, started = false, playing = false, lookahead, intervalId;
    const tempo = 186, beat = 60/tempo, scheduleAhead = 0.25;
    let nextTime = 0, send;

    // å’Œé¢¨Ã—ç·Šå¼µã®é›°å›²æ°—ï¼ˆçŸ­éŸ³éšå¯„ã‚Šï¼‰
    const scale = [57, 60, 62, 64, 65, 67, 69, 72].map(n=>n-12);
    const mtof = n => 440 * Math.pow(2, (n-69)/12);

    function init(){
      if(ac) return;
      ac = new (window.AudioContext || window.webkitAudioContext)();
      master = ac.createGain(); master.gain.value = 0.28;
      const comp = ac.createDynamicsCompressor();
      master.connect(comp); comp.connect(ac.destination);
      nextTime = ac.currentTime + 0.05;
    }

    function makeSend(g=0.15, t=0.22){
      const d = ac.createDelay(1.0); d.delayTime.value = t;
      const fb = ac.createGain(); fb.gain.value = 0.33;
      const w = ac.createGain(); w.gain.value = g;
      d.connect(fb).connect(d); d.connect(master);
      return {in:w, node:d};
    }

    function pluck(t, freq, vol=0.28, dur=0.16){
      const o = ac.createOscillator(); o.type="sawtooth"; o.frequency.value=freq;
      const f = ac.createBiquadFilter(); f.type="lowpass"; f.frequency.value=1050;
      const g = ac.createGain();
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.001, t+dur);
      o.connect(f).connect(g); g.connect(master); if(send) g.connect(send.in);
      o.start(t); o.stop(t+dur+0.02);
    }

    // åˆ€ã®é‹­ã•ï¼ˆçŸ­ãé‹­ã„ï¼‰
    function lead(t, freq, vol=0.22, dur=0.12){
      const o = ac.createOscillator(); o.type="triangle"; o.frequency.value=freq;
      const bpf = ac.createBiquadFilter(); bpf.type="bandpass"; bpf.frequency.value=2400; bpf.Q.value=1.6;
      const g = ac.createGain();
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.001, t+dur);
      o.connect(bpf).connect(g); g.connect(master); if(send) g.connect(send.in);
      o.frequency.exponentialRampToValueAtTime(freq*1.02, t+0.02);
      o.start(t); o.stop(t+dur+0.02);
    }

    // â€œä¸€ç¬ã®é€£æ‰“â€ã§æ°—æŒã¡ã‚ˆã•ï¼ˆé›°å›²æ°—ï¼‰
    function tremoloSlash(t, freq){
      const hits = 5;
      const gap = beat * 0.08;
      for(let i=0;i<hits;i++){
        lead(t + i*gap, freq*(1 + i*0.005), 0.16, 0.06);
      }
    }

    // å¤ªé¼“ï¼ˆé‡ã•ï¼‹ã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼‰
    function taiko(t, step){
      const barPos = step % 8;
      const accent = (barPos === 0) || (barPos === 6);
      const base = accent ? 0.95 : 0.60;

      const g = ac.createGain();
      g.gain.setValueAtTime(base, t);
      g.gain.exponentialRampToValueAtTime(0.001, t+0.22);

      const o = ac.createOscillator();
      o.type = "sine";
      o.frequency.setValueAtTime(accent ? 130 : 98, t);
      o.frequency.exponentialRampToValueAtTime(55, t+0.07);

      o.connect(g).connect(master);
      o.start(t); o.stop(t+0.22);

      // ã–ã‚‰ã¤ãï¼ˆæ‰“æ’ƒæ„Ÿï¼‰
      if(accent || (step%2===1)){
        const n = ac.createBufferSource();
        const buf = ac.createBuffer(1, ac.sampleRate*0.045, ac.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (accent?1.0:0.65);
        n.buffer = buf;

        const hp = ac.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=2600;
        const gg = ac.createGain(); gg.gain.value = accent?0.40:0.25;

        n.connect(hp).connect(gg).connect(master);
        if(send) gg.connect(send.in);
        n.start(t);
      }
    }

    // é€Ÿã„åˆ»ã¿ï¼ˆç·Šå¼µï¼‰
    function hat(t){
      const n = ac.createBufferSource();
      const buf = ac.createBuffer(1, ac.sampleRate*0.02, ac.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
      n.buffer = buf;
      const hp = ac.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=6000;
      const g = ac.createGain(); g.gain.value = 0.15;
      n.connect(hp).connect(g).connect(master);
      n.start(t);
    }

    // ä½éŸ³ï¼šåœ§
    function bass(t, step){
      const prog = [0, 5, 3, 6];
      const root = scale[ prog[Math.floor(step/8) % prog.length] ] - 12;
      pluck(t, mtof(root), 0.34, 0.18);
      if(step % 2 === 0) pluck(t + beat*0.5, mtof(root+12), 0.16, 0.10);
    }

    function scheduler(){
      const ct = ac.currentTime;
      while(nextTime < ct + scheduleAhead){
        const step = Math.floor(nextTime/beat);
        const barPos = step % 8;

        taiko(nextTime, step);

        // 8åˆ†åˆ»ã¿
        hat(nextTime);
        hat(nextTime + beat*0.5);

        bass(nextTime, step);

        // ã‚­ãƒ¡ï¼ˆ2å°ç¯€ã«1å›ï¼‰
        if(step % 16 === 12){
          const n = scale[(2 + (step%7)) % scale.length] + 12;
          tremoloSlash(nextTime, mtof(n));
        } else if(barPos === 2 || barPos === 5){
          const idx = (step + [0,2,4,1][barPos%4]) % scale.length;
          lead(nextTime, mtof(scale[idx] + 12), 0.18, 0.10);
        }

        nextTime += beat;
      }
    }

    function start(){
      init();
      if(started) return;
      ac.resume().catch(()=>{});
      send = makeSend(0.18, 0.23);
      lookahead = 25;
      intervalId = setInterval(scheduler, lookahead);
      started = true; playing = true;
    }

    function stop(){
      if(!started) return;
      if(intervalId){ clearInterval(intervalId); intervalId=null; }
      started=false; playing=false;
    }

    function toggle(){
      if(!started){ start(); return; }
      playing = !playing;
      master.gain.linearRampToValueAtTime(playing ? 0.28 : 0.0, ac.currentTime + 0.08);
    }

    // â˜…è£ã«å›ã£ãŸã‚‰æ­¢ã‚ã‚‹ï¼ˆã‚¹ãƒãƒ›å¯¾ç­–ï¼‰
    function pauseHard(){
      if(!ac) return;
      if(master) master.gain.setValueAtTime(0.0, ac.currentTime);
      if(intervalId){ clearInterval(intervalId); intervalId=null; }
      if(ac.state === "running") ac.suspend().catch(()=>{});
      playing = false;
    }

    // â˜…æˆ»ã£ãŸæ™‚ï¼šå‹æ‰‹ã«é³´ã‚‰ã•ãªã„ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ï¼‰
    function resumeHard(){
      if(!ac || !started) return;
      ac.resume().then(()=>{
        if(!intervalId){
          intervalId = setInterval(scheduler, lookahead);
        }
        master.gain.linearRampToValueAtTime(playing ? 0.28 : 0.0, ac.currentTime + 0.08);
      }).catch(()=>{});
    }

    return {
      start, stop, toggle,
      pauseHard, resumeHard,
      isStarted:()=>started, isPlaying:()=>playing
    };
  })();
  </script>
</body>
</html>
