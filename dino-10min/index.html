<script>
// ===== BGM (Web Audio, オリジナル生成) =====
const bgm = (() => {
  let ac, master, started = false, playing = false;
  let lookahead, intervalId;
  const tempo = 150;                 // BPM
  const beat = 60/tempo;             // 1拍の秒
  const scheduleAhead = 0.25;        // 先行スケジューリング時間
  let nextTime = 0;                  // 次のイベント時刻

  // 和風っぽい：Aマイナーペンタ(A C D E G)
  const scale = [57, 60, 62, 64, 67, 69, 72].map(n=>n-12); // A3中心
  const mtof = n => 440 * Math.pow(2, (n-69)/12);

  function init(){
    if(ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();
    master = ac.createGain();
    master.gain.value = 0.0; // 最初は無音、start時に上げる
    const comp = ac.createDynamicsCompressor();
    master.connect(comp); comp.connect(ac.destination);
  }

  // ちょいリバーブ代わりのフィードバックディレイ
  function makeSend(g=0.15, t=0.22){
    const d = ac.createDelay(1.0);
    d.delayTime.value = t;
    const fb = ac.createGain(); fb.gain.value = 0.35;
    const w = ac.createGain(); w.gain.value = g;
    w.connect(d);
    d.connect(fb).connect(d);
    d.connect(master);
    return {in:w, node:d};
  }
  let send;

  function playTaiko(t, step){
    const g = ac.createGain(); g.gain.setValueAtTime(0.8, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
    const o = ac.createOscillator(); o.type = "sine";
    o.frequency.setValueAtTime(100, t);
    o.frequency.exponentialRampToValueAtTime(60, t+0.08);
    o.connect(g).connect(master); o.start(t); o.stop(t+0.25);

    if(step%2===1){
      const n = ac.createBufferSource(); n.buffer = whiteNoise(0.07);
      const bp = ac.createBiquadFilter(); bp.type="bandpass"; bp.frequency.value = 1800; bp.Q.value=1.2;
      const gg = ac.createGain(); gg.gain.value=0.5;
      n.connect(bp).connect(gg);
      gg.connect(master); if(send) gg.connect(send.in);
      n.start(t);
    }
  }

  function playHat(t){
    const n = ac.createBufferSource(); n.buffer = whiteNoise(0.03);
    const hp = ac.createBiquadFilter(); hp.type="highpass"; hp.frequency.value = 4000;
    const g = ac.createGain(); g.gain.value = 0.22;
    n.connect(hp).connect(g).connect(master);
    n.start(t);
  }

  function playBass(t, step){
    const note = scale[(step*2)%scale.length]-12;
    simplePluck(t, mtof(note), 0.28, 0.18);
  }

  function playLead(t, step){
    const idx = (step + Math.floor(Math.random()*3)) % scale.length;
    const n = scale[idx] + 12; // 1オクターブ上
    simpleShamisen(t, mtof(n), 0.25, 0.22);
  }

  function simplePluck(t, freq, vol=0.3, dur=0.2){
    const o = ac.createOscillator(); o.type="sawtooth"; o.frequency.value=freq;
    const f = ac.createBiquadFilter(); f.type="lowpass"; f.frequency.value=1400;
    const g = ac.createGain(); g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.connect(f).connect(g);
    g.connect(master); if(send) g.connect(send.in);
    o.start(t); o.stop(t+dur+0.02);
  }

  function simpleShamisen(t, freq, vol=0.22, dur=0.18){
    const o = ac.createOscillator(); o.type="triangle"; o.frequency.value=freq;
    const a = ac.createGain(); a.gain.setValueAtTime(vol, t);
    a.gain.exponentialRampToValueAtTime(0.001, t+dur);
    const bpf = ac.createBiquadFilter(); bpf.type="bandpass"; bpf.frequency.value=1800; bpf.Q.value=1.2;
    o.connect(bpf).connect(a);
    a.connect(master); if(send) a.connect(send.in);
    o.frequency.exponentialRampToValueAtTime(freq*1.01, t+0.04);
    o.start(t); o.stop(t+dur+0.02);
  }

  function whiteNoise(len=0.05){
    const buffer = ac.createBuffer(1, Math.floor(ac.sampleRate*len), ac.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
    return buffer;
  }

  function scheduler(){
    if(!playing){ // ミュート中は空回ししない
      nextTime = ac.currentTime + beat*0.25;
      return;
    }
    const ct = ac.currentTime;
    while(nextTime < ct + scheduleAhead){
      const step = Math.floor(nextTime/beat);
      playTaiko(nextTime, step);
      playHat(nextTime);
      playHat(nextTime + beat*0.5);
      playBass(nextTime, step);
      if(step%2===0) playLead(nextTime, step);
      nextTime += beat;
    }
  }

  function start(){
    init();
    ac.resume();               // iOS 対策
    if(!send) send = makeSend(0.18, 0.23);
    nextTime = ac.currentTime + 0.05;     // ★毎回リセット
    if(intervalId) clearInterval(intervalId);
    lookahead = 25; // ms
    intervalId = setInterval(scheduler, lookahead);
    master.gain.linearRampToValueAtTime(0.28, ac.currentTime + 0.1);
    started = true; playing = true;
  }

  function stop(){
    if(!started) return;
    master.gain.linearRampToValueAtTime(0.0, ac.currentTime + 0.1);
    clearInterval(intervalId);
    intervalId = null;
    started = false; playing = false;
  }

  function toggle(){
    if(!started){ start(); return; }
    playing = !playing;
    master.gain.linearRampToValueAtTime(playing ? 0.28 : 0.0, ac.currentTime + 0.1);
  }

  return { start, stop, toggle, isStarted:()=>started, isPlaying:()=>playing };
})();
</script>
